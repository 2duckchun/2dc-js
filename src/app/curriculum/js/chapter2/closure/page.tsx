import styles from "@/styles/Chapter.module.scss";
import { chaptersInfo } from "../../JS_CHAPTER_INFO";
import CustomImageWithCaption from "@/app/_component/_common/CustomImageWithCaption";
import CodeBox from "@/app/_component/_curriculum/CodeBox";
import ActNavigator from "@/app/_component/_curriculum/ActNavigator";
import CustomLink from "@/app/_component/_common/CustomLink";
import ExerciseCard from "@/app/_component/_curriculum/ExcerciseCard";

const lessonCode = {};

export default function Chap0Act1() {
  return (
    <div className={styles.act_container}>
      <ActNavigator
        curriculum="js"
        highlightActNum={2}
        chapterInfo={chaptersInfo.chapter2}
      ></ActNavigator>
      <h1>클로저(closure)</h1>
      <p>
        클로저는 자바스크립트에서 굉장히 중요한 개념으로써, 함수와 깊은 연관이
        있습니다.
      </p>
      <p>클로저를 간단히 말하자면 함수가 함수를 리턴했을 때,</p>
      <p>
        리턴된 함수가 본인을 리턴한 함수가 사라졌음에도 불구하고, 그 스코프를
        참조할 수 있는 현상을 말합니다.
      </p>
      <p>사실 이렇게 말하면 전혀 간단하지가 않습니다.</p>
      <p>
        우리는 시험 문제를 푸는게 아니므로, 전체적인 맥락을 이해해야 합니다.
      </p>
      <p>
        그럼 클로저를 이해하기 위하, 실행 컨텍스트부터 이해 해보도록 하겠습니다.
      </p>

      <h2>실행 컨텍스트</h2>
      <p>실행 컨텍스트는 코드가 실행되는 환경을 의미합니다.</p>
      <p>
        전역의 코드가 실행되거나, 함수가 실행될 경우에 각각의 실행 컨텍스트도
        같이 생성되는데요.
      </p>
      <p>이 컨텍스트에는 코드의 실행에 필요한 환경들이 갖추어져 있습니다.</p>
      <p>이것을 전부 이해하기는 어렵습니다.</p>
      <p>
        하지만 클로저 현상을 이해하기 위해서는 렉시컬 환경을 꼭 먼저 이해해야
        합니다.
      </p>
      <p>일단 코드를 통해 실행 컨텍스트와 렉시컬 환경을 이해해봅시다.</p>

      <p>코드가 들어감</p>
      <p>자바스크립트는 싱글 스레드 기반의 언어입니다.</p>
      <p>즉, 한번에 하나의 작업만을 처리할 수 있는데요.</p>
      <p>작업의 대기열을 스택이라는 자료구조로 처리를 합니다.</p>
      <p>(프링글스 통을 생각하시면 이해가 됩니다.)</p>
      <p>먼저 코드를 실행하면 전역 컨텍스트가 형성이 됩니다.</p>
      <p>
        코드를 진행하고 나니 함수가 호출이 되었네요. 함수의 실행 컨텍스트가
        생깁니다.
      </p>
      <p>이제 전역 컨텍스트 스택 위에 함수 실행 컨텍스트가 쌓입니다.</p>
      <p>코드는 이 함수 실행 컨텍스트의 코드를 읽습니다.</p>
      <p>
        읽다보니 함수 내부에 함수가 선언되어 있고, 그 함수를 호출하고 있네요?
      </p>
      <p>이 함수의 실행 컨텍스트도 컨텍스트 스택위에 쌓입니다.</p>
      <p>
        그리고 console.log를 출력과 동시에 ~함수의 모든 코드가 다 읽혔습니다.
      </p>
      <p>작업이 끝난 ~함수의 실행 컨텍스트는 사라집니다.</p>
      <p>이제 다음 작업을 준비해야겠지요. b함수의 나머지 코드가 읽힙니다.</p>
      <p>
        그리고 다시 전역 컨텍스트로 돌아와서, 마지막 console.log가 읽힙니다.
      </p>
      <p>이것이 자바스크립트가 코드를 처리하는 방식입니다.</p>
      <p>
        자바스크립트의 함수는 코드를 선언하고 관리할 수 있는 하나의 소우주와
        같습니다.
      </p>
      <p>
        그래서 함수를 실행할때마다 그 함수에 맞는 실행 컨텍스트도 같이 생기게
        됩니다.
      </p>

      <h2>함수와 일급객체</h2>
      <p>어떻게 함수가 함수를 리턴할 수 있는 걸까요?</p>
      <p>자바스크립트의 함수는 일급 객체라는 특성을 지니고 있는데요.</p>
      <p>일급 객체의 특성은 다음과 같습니다.</p>
      <p>블라블라</p>
      <p>이것을 외우실 필요는 없습니다.</p>
      <p>이러한 특징 덕분에 함수에 다양한 것을 시도할 수 있고,</p>
      <p>클로저 현상도 설명할 수가 있습니다.</p>

      <h2>렉시컬 스코프</h2>
      <p>
        함수가 선언될 때, 변수를 참조할 수 있는 스코프도 함께 생성이 됩니다.
      </p>
      <p>
        이 때 스코프의 형성은 함수의 호출이 아니라, 함수의 선언에 영향을 받게
        됩니다.
      </p>
      <p>코드를 통해 보겠습니다.</p>
      <p>전역에 선언</p>
      <p>함수 내부에 선언</p>
      <p>
        즉, 함수 내부에 함수가 선언된다면, 내부에 선언된 함수의 스코프는 본인이
        선언된 함수의 스코프를 참조합니다.
      </p>

      <h3>함수가 함수를 리턴한다면?</h3>
      <p>여기서, 함수가 함수를 리턴해버린다면 어떨까요?</p>
      <p>외부 함수는 함수를 리턴하면서 생명주기가 끝나버렸습니다.</p>
      <p>
        하지만 내부 함수는 생명주기가 끝나버린 함수의 변수를 참조하고 있는
        상황입니다.
      </p>
      <p>
        외부 함수의 생명주기가 끝났음에도 불구하고, 그것을 참조하는 함수가 있을
        경우,
      </p>
      <p>
        렉시컬 환경은 사라지지 않고 남아있는 현상을 클로저 현상이라고 합니다!
      </p>
      <h2>클로저의 장점</h2>
      <h2>클로저의 단점</h2>
    </div>
  );
}
