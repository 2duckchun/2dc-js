---
id: operator
create_date: 2023-11-27 00:00
title: operator
---

# 연산자(Operator)

<YouWillLearn>
- 연산자와 피연산자를 구분할 수 있다.
- 연산자의 몇가지 종류에 대해 알게 된다.
- 표현식에 대해 알게 된다.
</YouWillLearn>


<TocData />

연산자에 대해 배우기 전에 잠깐 컴퓨터 구조에 관해 이야기를 하고 넘어갈까요?

컴퓨터는 사실 **CPU** 와 **RAM** 그 자체입니다. 모니터, 그래픽카드, 기타 등등은 단순 주변 기기일 뿐입니다. 게다가 CPU도 그리 똑똑하지만은 않습니다. 단순 계산만 잘 하는데 그마저도 덧셈밖에 못합니다. 즉 컴퓨터는 뭐다? 덧셈만 하는 기계라고 볼 수 있습니다.

그래서 연산자가 굉장히 중요합니다. 연산자는 CPU에게 연산을 하라고 명령을 내리기 때문입니다. 연산자가 없으면 CPU는 아무것도 하지 않겠지요.

## 연산자(Operator), 피연산자(Operand) {/*link*/}

```js
3 + 5;
```

CPU가 위의 코드를 수행했다고 가정하겠습니다. +라는 덧셈 연산자가 CPU에게 3과 5를 더하라는 연산을 지시했습니다. 여기서 3과 5는 연산을 당했습니다. 그래서 **피연산자** 라고 부릅니다. +는 당연히 **연산자** 입니다.

연산을 지시하는 주체는 **연산자(Operator)**, 연산을 당하는 주체는 **피연산자(Operand)** 이며, 피연산자를 **항** 이라고도 합니다.

<Recap>

```js
3 + 5;
```

**피연산자(항)** : 연산을 당하는 주체. 3, 5

**연산자** : 연산을 하는 주체. +
</Recap>

그런데 위의 코드에는 문제가 있습니다. 3과 5를 더한 값을 어디에도 저장하지 않는다는 것입니다. 우리가 변수를 선언해서 값을 할당하지 않았으니까요. 따라서 3과 5는 더해지자마자 휘발됩니다. 변수에 3과 5를 더한 값을 할당해볼까요?

## 연산자의 종류 {/*link*/}

### 할당 연산자(assignment Operator) {/*link*/}

```js
let sum = 3 + 5;
console.log(sum);
```

이렇게하면 3과 5가 더해진 값을 sum이라는 식별자에 할당할 수 있습니다. 값을 기억해놨으니 저 값을 언제고 사용할 수 있겠지요. 재미있는 것은 **저기 보이는 `=` 기호도 연산자** 라는 사실입니다.

수학에서는 좌항과 우항이 같다라는 의미로 = 기호를 사용하지요. 프로그래밍 언어에서는 다릅니다. 프로그래밍에서는 = 기호를 **_우측의 값(r-value)을 좌측(l-value)에 할당한다._** 라는 의미로 해석해야 합니다. 처음 배우시는 분들은 헷갈리실 수 있습니다. 보다 나은 이해를 위해 다른 연산자의 종류들도 공부해보겠습니다.

### 산술 연산자(arithmetic operator) {/*link*/}

<Recap>
+(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(모듈러)
</Recap>

산술 연산자는 우리가 알고있는 **덧셈**, **뺄셈**, **곱셈**, **나눗셈**과 연관이 있습니다. **모듈러**라는 특이한 연산도 있네요. 덧셈, 뺄셈, 곱셈에 대한 자세한 설명은 생략해도 될 것 같고, 나눗셈과 모듈러 연산에 대해서만 설명을 드리도록 하겠습니다.

```js
15 / 7; // 2.142857142857143
15 % 7; // 1
```

두 연산의 차이는 뭘까요? 간단히 말해 나눗셈(/)은 **몫을 구하기 위한 연산**이고, 모듈러(%)는 **나머지를 구하기 위한 연산입니다.**
15를 7로 나누면 2라는 몫이 남지요. 원래 C언어와 같은 다른 근본(?) 프로그래밍 언어들은 소숫점을 표현해주지 않습니다만, 자바스크립트는 워낙에 자유분방하여 소숫점 표현을 적절히 해줍니다.

그럼 15를 7로 **모듈러 연산**을 해봅시다. 1이 출력됩니다. 7에서 15를 나눈 나머지가 1이기 때문입니다.

처음 배우시는 분이라면 이해가 안가실 수 있습니다. 괘념치 마십시요! 당연히 그럴 수 있습니다. 사람이 뭔가를 이해하기 위해서는 절대적인 시간과 상대적인 시간이 모두 필요합니다. 이해가 안가면 연습을 해보시면 됩니다. 아래 문제를 풀어보시겠어요? 암산으로도 좋고 종이와 펜으로 푸셔도 좋습니다.

<QuestionCard title="/와 %를 각각 한번 이상 사용해 주어진 숫자를 0으로 만들어보세요.">
<Wrapper wraptype="show">

```js
5;
144;
5941;
25018;
67400;
```

</Wrapper>
<Wrapper wraptype="hide">

```js
5 / 5 % 1 // 0;
(144 / 12) % 10 % 2; // 0
(5941 / 5941) % 1; // 0
(25018 / 2) % 12509; // 0
(67400 / 200) % (67400 / 200); // 0
```
고생하셨습니다. 계산을 시도했다는 것 만으로도 대단한 것입니다!!

</Wrapper>
</QuestionCard>

### 비교 연산자(comparison operator) {/*link*/}
비교 연산자는 피연산자 사이의 상대적인 크기를 비교하는 연산자입니다. **크다**, **작다**, **크거나 같다**, **작거나 같다**, **같다**, **다르다** 를 표현할 수 있습니다. 이런 연산에 대한 답은 그렇다와 아니다밖에 없으므로 비교 연산자는 연산에 대한 결과로 **참(true)** 이나 **거짓(false)** 을 반환합니다.

```js
5 < 10 // 왼쪽 피연산자가 오른쪽 피연산자보다 작다. 사실이므로 true
5 > 10 // 왼쪽 피연산자가 오른쪽 피연산자보다 크다. 거짓이므로 false

5 <= 10 // 왼쪽 피연산자가 오른쪽 피연산자보다 작거나 같다. 사실이므로 true
5 >= 1 // 왼쪽 피연산자가 오른쪽 피연산자보다 크거나 같다. 사실이므로 true

5 === 5 // 왼쪽 피연산자가 오른쪽 피연산자와 동일하다. 사실이므로 true
5 !== 5 // 왼쪽 피연산자가 오른쪽 피연산자와 다르다. 거짓이므로 false
```

**같다(===) 연산자** 는 다소 생소하실 수 있습니다. 확실히 짚고 넘어가야할 점이 `= 연산자`는 `=== 연산자` 와 다릅니다. 각각 할당 연산자, 비교 연산자이므로 연산의 성질 자체가 다릅니다. 그 외 부등호와 관련된 비교 연산자는 다들 알고 계실것으로 가정하고 문제풀이는 생략하도록 하겠습니다. 기초는 중요한 것이지만 그래도 시간을 아낄 필요가 있습니다.

### 논리 연산자(logical operator) {/*link*/}

논리 연산자는 논리 연산 기호를 사용해서 좌항과 우항의 논리값을 판단합니다. 논리값에는 **true** 와 **false** 만 존재하므로 논리 연산자의 연산 결과는 **true** 와 **false** 만 존재합니다.
논리 연산자에는 **그리고(AND)**, **또는(OR)**, **부정(NOT)** 이 있는데요. 뭔가를 논증할때 사용하거나, 논리 회로에서 사용하는 것과 동일합니다. (논리학이나 논리회로를 모르셔도 아무 상관없습니다.)

```js
&& // AND, 그리고, 논리곱
|| // OR, 또는, 논리합
! // NOT, 부정
```

```js
let robb = false
let sansa = true
let arya = true
let bran = true
let rickon = false
let john = true

robb && sansa && arya && bran && rickon && john // false
robb || sansa || arya || bran || rickon || john // true
```

**논리곱(AND)** 과 **논리합(OR)** 의 성질은 약간 다릅니다.

**논리곱은 말그대로 논리의 곱셈** 입니다. *컴퓨터에서 true는 1을 상징하고 false는 0을 상징* 하는데요. 어떤 값에 0을 곱하면 최종적인 값은 0입니다. 따라서 논리곱이 true가 되려면 연산에 이용되는 모든 피연산자가 true값을 가지고 있어야 합니다.

**반면에 논리합은 논리의 덧셈** 이라고 볼 수 있습니다. 논리값은 1과 0밖에 없습니다. 그러므로 논리합의 개념에서는 연산에 이용되는 모든 피연산자 중 하나만 true여도 그 논리식은 true가 되는 것이지요.

부정 연산자도 한번 볼까요?

```js
const stark = false
!stark // true
!!stark // false

const lannister = true
!lannister // false
!!lanister // true
```

**부정 연산자는 피연산자의 논리값을 바꿔줍니다.** true였다면 false로, false였다면 true로 말이지요. 어려운 개념은 아닙니다.

그럼 논리 연산자의 빠른 습득을 위해 문제를 하나 풀어봅시다. 이번에도 노트와 펜을 준비해주시면 좋을 것 같습니다.

<QuestionCard title="최종적인 논리값은 true일까요 false일까요?">
<Wrapper wraptype="show">

```js
true && false || !(true && false) || false 
```

</Wrapper>
<Wrapper wraptype="hide">

논리곱을 먼저 계산한 후 논리 합을 계산하면 생각보다 쉽습니다.

```js
const sub1 = true && false // false
const sub2 = !(true && false) // true
const sub3 = false // false

sub1 || sub2 || sub3 // true 
```

답은 **true** 가 나옵니다.

문제가 커보인다면 문제를 작게 쪼개보는 연습을 해보세요! 프로그래밍을 하시려면 익숙해지셔야 하는 과정입니다.

</Wrapper>
</QuestionCard>

처음엔 복잡하게 느껴지실수도 있지만, 금방 적응 되실겁니다.

한 문제 더 풀어보시죠. 이번 문제는 방금 전에 푸신 문제보다 훨씬 쉽습니다.

<QuestionCard title="최종적인 논리값은 true일까요 false일까요?">
<Wrapper wraptype="show">

```js
false && true && true && true && true && true // true일까요? false일까요?

true || false && false && false && false && false // true일까요? false일까요?
```

</Wrapper>

<Wrapper wraptype="hide">

논리곱을 먼저 계산한 후 논리 합을 계산하면 생각보다 쉽습니다.

```js
false && true && true && true && true && true // 정답은 false

true || false && false && false && false && false // 정답은 true
```

첫번째 논리 연산값은 false, 두번째 논리 연산값은 true가 나옵니다.

사실 이 문제는 **쇼트 서킷(short circuit)** 을 보여드리기 위해 제작한 문제인데요.

```js
false && true && true && true && true && true 
// 논리곱인데 맨 앞이 false라면 뒤에 있는 피연산자들을 굳이 연산할 이유가 없다. (어짜피 최종값은 false)

true || false && false && false && false && false
// 논리합인데 맨 앞이 true라면 뒤에 있는 피연산자들을 굳이 연산할 이유가 없다. (어짜피 최종값은 true)
```

논리합 연산의 경우에 특정 항이 true인 것이 확실하다면 남은 항은 더이상 연산하지 않습니다.
논리곱의 경우에도 마찬가지로 특정 항이 false가 나오면 남은 항들은 연산하지 않습니다. 이러한 현상은 프로그래밍 언어 모두에 공통적으로 일어납니다.

이 현상은 아래와 같이 사용해볼 수 있습니다.

```js
값싼연산 && 값싼연산 && 값비싼연산

값싼연산 || 값싼연산 || 값비싼연산
```

만약 특정 논리를 수행하는 코드들이 참, 거짓을 반환할 경우, 그리고 금방 끝나는 연산과 시간이 좀 걸리는 연산이 있을 경우에 위와 같이 코드하면 연산 시간을 약간이라도 절약할 수가 있겠지요.

</Wrapper>
</QuestionCard>


typeof 연산자...