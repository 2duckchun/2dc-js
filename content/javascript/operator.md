---
id: operator
create_date: 2023-11-27 00:00
title: operator
---

# 연산자(Operator)

<YouWillLearn>
- 연산자와 피연산자를 구분할 수 있다.
- 연산자의 몇가지 종류에 대해 알게 된다.
</YouWillLearn>

<InlineToc>
  <TocData />
</InlineToc>

연산자에 대해 배우기 전에 잠깐 컴퓨터 구조에 관해 이야기를 하고 넘어갈까요?

컴퓨터는 사실 **CPU** 와 **RAM** 그 자체입니다. 굉장히 간단하게 구성되어 있죠? 게다가 그리 똑똑하지도 않습니다. 단순 계산만 잘 하는데 그마저도 덧셈밖에 못합니다. 즉 덧셈 연산만 하는 기계라고 볼 수 있습니다.

그래서 우리는 컴퓨터에게 명령을 내리기 위해 연산자를 사용합니다. 연산자는 CPU에게 연산을 하라고 명령을 내리기 때문인데요. 연산자가 없으면 CPU는 아무 것도 하지 못하겠지요.

<h2 id="operator-operand">연산자(Operator), 피연산자(Operand)</h2>

```js
3 + 5;
```

CPU가 위의 코드를 수행했다고 가정하겠습니다. +라는 덧셈 연산자가 CPU에게 3과 5를 더하라는 연산을 지시했습니다. 여기서 3과 5는 연산을 당했습니다. 그래서 **피연산자** 라고 부릅니다. +는 당연히 **연산자** 입니다.

연산을 지시하는 주체는 **연산자(Operator)**, 연산을 당하는 주체는 **피연산자(Operand)** 이며, 피연산자를 **항** 이라고도 합니다.

<Recap>

```js
3 + 5;
```

**피연산자(항)** : 연산을 당하는 주체. 3, 5

**연산자** : 연산을 하는 주체. +
</Recap>

위의 코드에서 3과 5를 더한 값인 8은 어디에도 저장되지 않습니다. 우리가 이 값을 변수에 할당하지 않았기 때문입니다. 따라서 3과 5는 더해지자마자 휘발됩니다. 연산한 값을 사용하기 위해서는 할당 연산자를 사용해 특정 변수에 값을 할당해야 합니다. 그럼 변수에 3과 5를 더한 값을 할당해볼까요?

<h2 id="kind-of-operator">연산자의 종류</h2>

<h3 id="assignment-operator">할당 연산자(assignment operator)</h3>

```js
let sum = 3 + 5;
console.log(sum);
```

이렇게하면 3과 5가 더해진 값을 sum이라는 식별자에 할당할 수 있습니다. 값을 기억해놨으니 저 값을 언제고 사용할 수 있겠지요. 재미있는 것은 **저기 보이는 `=` 기호도 연산자** 라는 사실입니다. 그래서 =을 *할당 연산자* 라고 합니다. 단순 사칙연산 기호만 연산자가 아님을 기억해주시기 바랍니다. 그럼 다른 연산자들도 공부해볼까요?


<h3 id="arithmetic-operator">산술 연산자(arithmetic operator)</h3>

<Recap>
+(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(모듈러)
</Recap>

산술 연산자는 우리가 알고있는 **덧셈**, **뺄셈**, **곱셈**, **나눗셈**과 연관이 있습니다. **모듈러**라는 특이한 연산도 있네요. 덧셈, 뺄셈, 곱셈에 대한 자세한 설명은 생략해도 될 것 같고, 나눗셈과 모듈러 연산에 대해서만 설명을 드리도록 하겠습니다.

```js
15 / 7; // 2.142857142857143
15 % 7; // 1
```

두 연산의 차이는 뭘까요? 간단히 말해 나눗셈(/)은 **몫을 구하기 위한 연산**이고, 모듈러(%)는 **나머지를 구하기 위한 연산입니다.**
15를 7로 나누면 2라는 몫이 남지요. 원래 C언어와 같은 다른 근본(?) 프로그래밍 언어들은 소숫점을 표현해주지 않습니다만, 자바스크립트는 워낙에 자유분방하여 소숫점 표현을 적절히 해줍니다.

그럼 15를 7로 **모듈러 연산**을 해봅시다. 1이 출력됩니다. 7에서 15를 나눈 나머지가 1이기 때문입니다.

처음 배우시는 분이라면 이해가 안가실 수 있습니다. 괘념치 마십시요! 당연히 그럴 수 있습니다. 사람이 뭔가를 이해하기 위해서는 절대적인 시간과 상대적인 시간이 모두 필요합니다. 이해가 안가면 연습을 해보시면 됩니다. 아래 문제를 풀어보시겠어요? 암산으로도 좋고 종이와 펜으로 푸셔도 좋습니다.

<QuestionCard title="/와 %를 각각 한번 이상 사용해 주어진 숫자를 0으로 만들어보세요.">
<Wrapper wraptype="show">

```js
5;
144;
5941;
25018;
67400;
```

</Wrapper>
<Wrapper wraptype="hide">

```js
5 / 5 % 1 // 0;
(144 / 12) % 10 % 2; // 0
(5941 / 5941) % 1; // 0
(25018 / 2) % 12509; // 0
(67400 / 200) % (67400 / 200); // 0
```
고생하셨습니다. 계산을 시도했다는 것 만으로도 대단한 것입니다!!

</Wrapper>
</QuestionCard>

<h3 id="comparison-operator">비교 연산자(comparison operator)</h3>

비교 연산자는 피연산자 사이의 상대적인 크기를 비교하는 연산자입니다. **크다**, **작다**, **크거나 같다**, **작거나 같다**, **같다**, **다르다** 를 표현할 수 있습니다. 이런 연산에 대한 답은 그렇다와 아니다밖에 없으므로 비교 연산자는 연산에 대한 결과로 **참(true)** 이나 **거짓(false)** 을 반환합니다.

```js
5 < 10 // 왼쪽 피연산자가 오른쪽 피연산자보다 작다. 사실이므로 true
5 > 10 // 왼쪽 피연산자가 오른쪽 피연산자보다 크다. 거짓이므로 false

5 <= 10 // 왼쪽 피연산자가 오른쪽 피연산자보다 작거나 같다. 사실이므로 true
5 >= 1 // 왼쪽 피연산자가 오른쪽 피연산자보다 크거나 같다. 사실이므로 true

5 === 5 // 왼쪽 피연산자가 오른쪽 피연산자와 동일하다. 사실이므로 true
5 !== 5 // 왼쪽 피연산자가 오른쪽 피연산자와 다르다. 거짓이므로 false
```

**같다(===) 연산자** 는 다소 생소하실 수 있습니다. 확실히 짚고 넘어가야할 점이 `= 연산자`는 `=== 연산자` 와 다릅니다. 각각 할당 연산자, 비교 연산자이므로 연산의 성질 자체가 다릅니다. 그 외 부등호와 관련된 비교 연산자는 다들 알고 계실것으로 가정하고 문제풀이는 생략하도록 하겠습니다. 기초는 중요한 것이지만 그래도 시간을 아낄 필요가 있습니다.

<h3 id="logical-operator">논리 연산자(comparison operator)</h3>

논리 연산자는 논리 연산 기호를 사용해서 좌항과 우항의 논리값을 판단합니다. 논리값에는 **true** 와 **false** 만 존재하므로 논리 연산자의 연산 결과는 **true** 와 **false** 만 존재합니다.
논리 연산자에는 **그리고(AND)**, **또는(OR)**, **부정(NOT)** 이 있는데요. 뭔가를 논증할때 사용하거나, 논리 회로에서 사용하는 것과 동일합니다. (논리학이나 논리회로를 모르셔도 아무 상관없습니다.)

```js
&& // AND, 그리고, 논리곱
|| // OR, 또는, 논리합
! // NOT, 부정
```

```js
let robb = false
let sansa = true
let arya = true
let bran = true
let rickon = false
let john = true

robb && sansa && arya && bran && rickon && john // false
robb || sansa || arya || bran || rickon || john // true
```

**논리곱(AND)** 과 **논리합(OR)** 의 성질은 약간 다릅니다.

**논리곱은 말그대로 논리의 곱셈** 입니다. *컴퓨터에서 true는 1을 상징하고 false는 0을 상징* 하는데요. 어떤 값에 0을 곱하면 최종적인 값은 0입니다. 따라서 논리곱이 true가 되려면 연산에 이용되는 모든 피연산자가 true값을 가지고 있어야 합니다.

**반면에 논리합은 논리의 덧셈** 이라고 볼 수 있습니다. 논리값은 1과 0밖에 없습니다. 그러므로 논리합의 개념에서는 연산에 이용되는 모든 피연산자 중 하나만 true여도 그 논리식은 true가 되는 것이지요.

부정 연산자도 한번 볼까요?

```js
const stark = false
!stark // true
!!stark // false

const lannister = true
!lannister // false
!!lanister // true
```

**부정 연산자는 피연산자의 논리값을 바꿔줍니다.** true였다면 false로, false였다면 true로 말이지요. 어려운 개념은 아닙니다.

그럼 논리 연산자의 빠른 습득을 위해 문제를 하나 풀어봅시다. 이번에도 노트와 펜을 준비해주시면 좋을 것 같습니다.

<QuestionCard title="최종적인 논리값은 true일까요 false일까요?">
<Wrapper wraptype="show">

```js
true && false || !(true && false) || false 
```

</Wrapper>
<Wrapper wraptype="hide">

논리곱을 먼저 계산한 후 논리 합을 계산하면 생각보다 쉽습니다.

```js
const sub1 = true && false // false
const sub2 = !(true && false) // true
const sub3 = false // false

sub1 || sub2 || sub3 // true 
```

답은 **true** 가 나옵니다.

문제가 커보인다면 문제를 작게 쪼개보는 연습을 해보세요! 프로그래밍을 하시려면 익숙해지셔야 하는 과정입니다.

</Wrapper>
</QuestionCard>

처음엔 복잡하게 느껴지실수도 있지만, 금방 적응 되실겁니다.

한 문제 더 풀어보시죠. 이번 문제는 방금 전에 푸신 문제보다 훨씬 쉽습니다.

<QuestionCard title="최종적인 논리값은 true일까요 false일까요?">
<Wrapper wraptype="show">

```js
false && true && true && true && true && true // true일까요? false일까요?

true || false && false && false && false && false // true일까요? false일까요?
```

</Wrapper>

<Wrapper wraptype="hide">

논리곱을 먼저 계산한 후 논리 합을 계산하면 생각보다 쉽습니다.

```js
false && true && true && true && true && true // 정답은 false

true || false && false && false && false && false // 정답은 true
```

첫번째 논리 연산값은 false, 두번째 논리 연산값은 true가 나옵니다.

사실 이 문제는 **쇼트 서킷(short circuit)** 을 보여드리기 위해 제작한 문제인데요.

```js
false && true && true && true && true && true 
// 논리곱인데 맨 앞이 false라면 뒤에 있는 피연산자들을 굳이 연산할 이유가 없다. (어짜피 최종값은 false)

true || false && false && false && false && false
// 논리합인데 맨 앞이 true라면 뒤에 있는 피연산자들을 굳이 연산할 이유가 없다. (어짜피 최종값은 true)
```

논리합 연산의 경우에 특정 항이 true인 것이 확실하다면 남은 항은 더이상 연산하지 않습니다.
논리곱의 경우에도 마찬가지로 특정 항이 false가 나오면 남은 항들은 연산하지 않습니다. 이러한 현상은 프로그래밍 언어 모두에 공통적으로 일어납니다.

이 현상은 아래와 같이 사용해볼 수 있습니다.

```js
값싼연산 && 값싼연산 && 값비싼연산

값싼연산 || 값싼연산 || 값비싼연산
```

만약 특정 논리를 수행하는 코드들이 참, 거짓을 반환할 경우, 그리고 금방 끝나는 연산과 시간이 좀 걸리는 연산이 있을 경우에 위와 같이 코드하면 연산 시간을 약간이라도 절약할 수가 있겠지요.

</Wrapper>
</QuestionCard>

<h3 id="ternary-operator">조건(삼항) 연산자(conditional operator)</h3>

조건 연산자는 세 개의 피연산자를 받는 유일한 연산자입니다. 세 개의 피연산자가 필요해서 **삼항 연산자** 라고도 합니다.
삼항 연산자는 주어진 조건에 따라 두 값 중 하나를 반환하며, 구문은 아래와 같습니다.

```js
condition ? val1 : val2
```

*condition이 true라면 val1을 반환하고 그 외의 경우에는 val2를 반환합니다*. 조건에 따라 특정 값을 반환한다는 점에서 삼항 연산자부터 진정한 프로그래밍의 시작선이라고도 볼 수도 있겠습니다. (개인적으로 프로그래밍은 주어진 경우의 수에 따라 어떤 코드가 실행될지 작성하는 것이라고 생각합니다... 그런 의미에서요.. ㅎㅎ)

삼항 연산자는 아래와 같이 사용할 수 있습니다.

```js
let status = age >= 18 ? "성인" : "미성년자"
```

status에는 age의 값에 따라 성인 또는 미성년자가 할당됩니다.



<h3 id="typeof-operator">typeof 연산자(typeof operator)</h3>

typeof 연산자는 피연산자의 타입을 알려주는 연산자입니다.

```js
typeof "문자열" // 'string'
typeof 1 // 'number'
typeof true // 'boolean'
typeof undefined // 'undefined'
typeof null // 'object'

typeof {} // 'object'
typeof [] // 'object'
typeof function() {} // 'function'
```

자바스크립트의 데이터는 특정한 **타입** 으로 이루어져 있습니다. 그 타입을 **자료형** 또는 **데이터 타입** 이라고 하는데요. typeof 연산자를 사용하면 피연산자의 타입을 확인할 수 있습니다. 그럼 이 기회에 타입이 뭔지 한번 훑어보는 시간도 가져보아야 겠지요.

그러므로... 다음 챕터에는 자바스크립트의 **데이터 타입**에 대해 공부해보겠습니다.



<h2 id="summary">요약</h2>
<Recap>
- **연산자** 는 CPU에게 연산을 하라고 지시하며, 특정한 값을 반환한다.
- **할당 연산자** 는 오른쪽 피연산자 값(r-value)을 왼쪽 피연산자(l-value)에 할당한다.
- **산술 연산자** 는 사칙연산과 거의 같다. 모듈러 연산(나머지 연산)이 좀 생소할 수 있다.
- **비교 연산자** 는 좌, 우항의 피연산자를 비교한 뒤 true나 false를 반환한다.
- **논리 연산자** 는 논리곱, 논리합, 부정 등 논리공식을 통해 특정 논리식의 true와 false를 판단한다.
- **조건(삼항) 연산자** 는 주어진 조건에 따라 두 값중 하나를 반환한다.
- **typeof 연산자** 는 피연산자의 데이터 타입을 반환한다.
</Recap>

사실 연산자 종류는 이것보다 많습니다. 하지만 여기서 모든 연산자를 다루기에는 공부 효율도 좋지 않을 뿐더러, 상당히 지루할 것입니다. 따라서 가장 많이 쓰이는 연산자들을 우선적으로 소개해드렸습니다.
나중에 연산자에 대한 심화적인 공부가 필요하실때는 mdn 문서를 참조하시면 좋을 것 같습니다. 구글링도 좋고요. 일단 기본만 갖추시고 필요한 것들은 그때그때 찾아 쓰시는게 편하고 빠른 길입니다.

[MDN 연산자 공식 문서(한글)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_operators#%EC%A1%B0%EA%B1%B4_%EC%82%BC%ED%95%AD_%EC%97%B0%EC%82%B0%EC%9E%90)